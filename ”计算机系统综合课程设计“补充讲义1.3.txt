第7章

BIOS 设计

一个计算机系统光有硬件是不行的，还必须有软件配合，而软件中与硬件联系最紧密的
就是 BIOS。

7.1

堆栈的实现

在本章中将要实现 MiniSys 中最底层的软件 BIOS，它会以子程序的方式向上层软件提
供服务，在这些子程序中会用到一些通用寄存器，如果希望不破坏这些寄存器原来的值，就
应该在使用这些寄存器之前将其保存，使用后再将其恢复。保存寄存器值的最好办法就是利
用堆栈。
在 PC 汇编中，由于 X86 汇编有专门的堆栈指令，因此在硬件上支持堆栈操作，所以对
程序员来说，堆栈的操作是很简单的。但 MiniSys 除了定义了 SP（堆栈指针）寄存器外，
并没有设计任何堆栈操作指令，所以只能用软件来模仿堆栈的压栈和退栈过程。
可以使用数据 RAM 的一部分作为堆栈，它们应该是连续的，与 RAM 的其他数据区很
容易分开的，比如图 7.1 所示的布局(本章按照 64KB RAM 设计，其他尺寸的 RAM 读者自
行设计，图中 0FFFFH 表示 16 进制数 0xFFFF，其它数字同)。从图 7.1 中可以看到，堆栈共
用了 512 个字节，由于数据是 32 位的，所以堆栈总共有 128 个单元。堆栈的操作以及堆栈
越界检查全由软件实现。要注意，如果按图 7.1 上的的地址将这部分给 BIOS 的话，要通知
应用程序员避开这个地址范围。
512B 堆栈

0FFFFH
0FE00H

65024B 数据区

0000H

图 7.1 堆栈的设计

按照图 7.1 所示设置堆栈的话，系统初始化的时候令$sp=0FFFFH，这一步由软件实现
还是硬件实现，读者可以根据的需要自己决定。如果由软件来实现的，通常应该是 BIOS 的
初始化模块中完成。要注意堆栈越界的检查也得由软件实现，通常堆栈越界采用回转法，即
如果 SP 的值达到 0FE00H，则再压栈，就会从 0FFFFH 重新开始，当然，这样的结果必然
造成系统失败。还有一种办法，当堆栈越界后，让系统进入一个死循环，这样在看门狗的作
用下，系统会重新启动。另外，也可以在堆栈越界的时候在数码管上输出特定的错误代码。
压栈操作：
SW $S0, 0($SP)

; 假设将$S0 寄存器内容压栈，先将$S0 内容存到堆栈中
-124-

ADDI $SP, $SP, -4

; 堆栈指针调整（$SP=$SP-4）

退栈操作：
ADDI $SP, $SP, 4

; 堆栈指针调整（$SP=$SP+4）

LW $S0, 0($SP)

; 假设是栈顶内容弹出到$S0 中，将栈顶内容读出到$S0 中

堆栈越界检查请读者自行完成。

7.2

BIOS 的基本功能

BIOS 及其基本功能
BIOS（Basic Input Output System）是基本输入输出系统，它是一组程序，这组程序（BIOS
程序）在系统开机后，被首先启动执行，它为计算机提供最低级的、最直接的硬件初始化和
外围设备的控制与支持。BIOS 程序在软件系统层次中处于最底层，它不仅直接控制计算机
的硬件，同时也在其他软件（包括操作系统）与硬件之间架起一座桥梁。通常情况下 BIOS
采用汇编语言编写。
BIOS 的主要功能包括：

•

•
•

•

开机自检(PowerOn SelfTest, POST) BIOS 的 POST 功能会对处理器中各种寄存
器，各种接口部件的状态进行检查，对系统内存进行测试。自检中如果发现严重错
误则会停机，而如果发现的错误并不严重，则给出提示或声音报警提示（如果系统
支持的话）。
初始化 BIOS 会协助硬件对有关部件做初始化设置，并且设置中断向量表。
提供系统功能调用 BIOS 直接与计算机的 I/O 端口进行数据交换，通过对 I/O 端
口发送命令以及传送与接收数据，来直接操作外围设备。BIOS 将对这些设备的操
作代码写成系统功能函数，并为上层软件（包括操作系统）提供调用这些函数的软
件接口。另外，BIOS 还提供了各中断的原始中断处理程序，最简单的处理程序只
包含 JR 一条指令，通常操作系统以及一些应用软件会替换其中的一些中断处理程
序。
系统启动自举 BIOS 在做好自检和初始化之后，就会引导操作系统，如果没有操
作系统，就会根据规定的位置引导用户程序。

BIOS 程序的设计
由上一节描述可知，BIOS 的程序有两类，第一类是系统启动后会自动运行的，主要是
初始化、开机自检和系统启动自举部分，第二类在系统启动的时候不会自动运行，而是靠其
他软件调用后再运行，这主要是系统功能调用部分。
BIOS 程序的起始地址
由硬件设计知道，MiniSys 系统启动后，PC 的初始值为 0000H，这将是系统第 1 条指令
的地址。BIOS 的第一类程序中的第 1 条指令显然会是整个系统第 1 条指令。因此，从这个
角度上说，BIOS 程序的初始化程序可以放在程序 ROM 的开始位置，之后分别是开机自检、
-125-

系统启动自举和系统功能调用部分，整个 BIOS 程序之后再安排用户的程序，在 BIOS 系统
启动自举部分通过跳转语句跳到用户程序起始地址。当然，这种情况下，用户程序所在的位
置会受到 BIOS 程序大小的影响，因此要定位其起始地址并不容易。
另一种安排的方法是，
把 BIOS 程序安排在程序 ROM 的高端地址处，
如果有堆栈的话，
就安排在 0FE00H 向下的地址空间，否则就安排在 0FFFH 向下的地址空间。BIOS 程序的次
序依然是初始化程序、自检程序、系统启动自举程序和系统功能调用部分。在 0000H 处放
上一句跳转语句跳转到 BIOS 的第一句。这种方法有一个好处，用户程序的起始地址可以固
定在 0004H 的地址上，下面的设计将采用这种方法。
BIOS 程序与用户程序的结合
这部分请看本手册第 8 章。
BIOS 系统功能调用的设计
BIOS 程序中的系统功能调用是一组子程序，但这组子程序又要方便用户程序调用。注
意 MiniSys-1A 没有系统功能调用指令，
所以对它们的调用只能像普通的子程序一样调用，
即用 JAL 指令调用，用 JR $RA 指令返回。JAL 指令需要有子程序的目标地址，因为通常
会单独翻译或汇编用户程序和 BIOS 程序，因此，该地址不太容易用符号地址（标号）的方
法给出，需要各系统功能调用子程序固定好自己的起始地址，并将该起始地址公开给程序员，
以便程序员在调用的时候能够直接使用该地址。固定起始地址可以用.text [addr]伪指
令。
BIOS 系统功能调用设计还要注意规定好入口参数和出口参数。系统已经约定了$v0 和
$v1 作为子程序非浮点返回值的存放寄存器，而$a0~$a3 存放子程序的非浮点调用参数，设
计者只需明确各寄存器的具体意义即可。另外，系统功能调用中用到的寄存器要保存好其原
始值，返回时需要恢复它们。如果堆栈很紧张，则只能使用$t0~$t9 这 10 个寄存器，因为它
们的原始值可以不被保存。
需要注意的是，MiniSys-1A 不支持子程序嵌套，所以用户程序要避免在子程序中调用
其他子程序，包括系统功能调用，否则可能造成$ra 中存放的返回地址丢失。如要扩展到嵌
套子程序调用，可考虑用好堆栈。

7.3

BIOS 基本功能设计

初始化模块
从上一节的分析知道，初始化模块起始包括 3 个部分，系统初始化，自检和系统自举。
MiniSys 的初始化没有其他任务，唯一的任务就是将$sp 寄存器的值置为 0FFFFH。系统
自举也简单，就是用跳转指令将 PC 修改 0004H。
关于自检部分，通常要检查 RAM 和各个外设接口的情况，对于 RAM 的检查一般是向
RAM 的每个字节写入 55H 和 0AAH 这样的数据，然后再读出，看有没有问题，但对于
MiniSys-1A 来说，这里可能有个问题，MiniSys-1A 的 RAM 上电时可能就有初始值，所以，
-126-

检查时要注意保护好原来的内容，一般在嵌入式系统中也可以省去这一步。对于外设的检查
主要是看外设接口是否正常工作。这里以键盘、数码管和 LED 灯为例，假设系统复位的时
候用户是不会按键的，所以此时检测键盘，应该是无键读入，如果有键就算错误。对数码管
的检查，只是将 8 个数码管依次输出 00000000H，11111111H，22222222H……，99999999H，
由用户判断数码管是不是好的。LED 灯的检查可用全亮和全灭来测试，由用户判断 LED 灯
是不是好的。当然，如果读者设计了蜂鸣器，可以让蜂鸣器叫一声来检查。
最后总结一下初始模块的工作：1）初始化$sp；2）检测 RAM；3）检测键盘；4）检测
数码管；5）检查 LED 灯；6）可选的检查蜂鸣器；7）启动用户程序。
MiniSys-1A 中采用的是 BIOS 放在 ROM 高端，用户程序起始地址固定在 0004H 的方
法。
下面是初始化模块的 BIOS 程序开始部分。
.text 0x0000
J

0xFC00

; 跳转到 BIOS 的首地址

.text 0Xfc00
$SP, $ZEOR, 0xFFFF

ADDI

$T0, $ZERO, 0

; RAM 起始地址

ADDI

$T1, $ZERO, 0XFFFF

; RAM 结束地址

ADDI

$T2, $ZERO, 0X55AA55AA

ADDI

$T3, $ZERO, 0XAA55AA55

ADDI

$S0, $ZERO, 0E1

; RAM 错误码

$T8, 0($T0)

; 取此地址 RAM 原来的值

CHKRAM: LW

; 自己完成检查 RAM

......
CHKKEY: ADDI

$S0, $ZERO, 0E2

CHKLED: ANDI

; key 错误码
; 自己完成检查键盘

......

DIPS:

; 初始化$sp

ADDI

$T0, $ZERO, 0

; led 错误码

......

; 自己完成检查 led

......

; 自己完成检查数码管

J
ERROR:

......

LP:

......
J

0004

; 启动用户程序
; 自己完成检查在数码管上输出错误码
; 复位看门狗

LP

7 段 LED 数码管显示模块（只是例子，可自己定义）
7 段 LED 数 码 管 显 示 实 际 上 是 很 简 单 的 操 作 过 程 ， 只 需 要 向 0xFFFFFC00 和
0xFFFFFC02 端口分别写一个双字节数据，
就能够将 8 位数码管的显示全部完成，
但有时候，
只需要写 8 位数码管中的某一位，因此，BIOS 提供的 7 段 LED 数码管显示系统功能调用将
提供 8 位数码管同时显示和修改其中任何一位数码管显示的功能
（利用 0xFFFFFC04 端口）。
7 段 LED 数码管显示系统功能调用入口地址：0XFC88H
1）0 号功能——写数码管
-127-

$a0 = 0 ; 功能号

入口参数:

$a2=要写的双字节数据（低 4 位数码管的数据）。
$a3=要写的双字节数据（高 4 位数码管的数据）。
出口参数： 无。
根据$a2 中的 16 位数同时显示 4 位数码管的数据，数据格式见 MOOC。

功能：

2）1 号功能——指定某位数码管显示
$a0 = 1 ; 功能号

入口参数:

$a1=0~7 ; 要显示的数码管的位数。
$a2=要写的双字节数据（低 4 位数码管数据）。
$a3=要写的双字节数据（高 4 位数码管数据）。
出口参数： 无。
功能： 根据$a1 中的位数，在该位数码管上显示$a2 和$a3 中的数据，而其他位的
数据不变，数据格式见 4.6 节和 MOOC。
有了这两个功能调用后，用户应该使用它们来操作 LED 数码管，而不能自行操作，原
因是在完成 1 号功能的时候，BIOS 必须保存当前显示的数据，这样才能通过逻辑运算，为
8 位中单独的某位赋值。而如果用户程序自行写 0xFFFFFC00 等端口来操作数码管，则 BIOS
不再知道当前显示的是什么数据，无法完成指定某位数码管显示（因为硬件没有返回当前显
示数据的功能）。
请自行完成 BIOS 中 LED 数码管显示模块的源程序。
.DATA 0XFDFC ; 定义数据
LEDDATA

DD

0

.TEXT 0XFC88 ; 定义代码
SW

$S0, 0($SP)

ADDI

$SP, $SP, -4

SW

$S1, 0($SP)

ADDI

$SP, $SP, -4

; 将$S0 寄存器内容压栈
; 将$S1 寄存器内容压栈

......
JR

$RA

; 子程序返回

键盘功能模块
在计算机中对键盘的使用无非是读键值，然后按照键值做相应的操作。在 BIOS 中提供
的键盘功能就是提供读键的功能，但根据通常使用键盘的习惯，设计中提供了两种读键方式，
一种是等待读键，即程序到此时暂时停止下来，直到读到按键值再继续执行下去；另一种是
判断有无按键，如果没有，程序继续下去，如果有，处理按键后程序继续下去。前一种是事
务处理类的程序常用的方式，而后一种在自动控制、嵌入式领域经常会用到，因为在这种情
况下，系统主要要处理实时监测和控制，人机交互是次要的，更不允许因为人机交互而暂停
-128-

程序的执行。
另外，硬件扫描后的键值有可能是直接将行值与列值拼成一个字节，这样的键值不易理
解，在 BIOS 键盘功能中，将 4×4 的键盘的按键按照从左到右，从上到下的顺序依次编号
为 0， 1，2，……，15，其中左上角的键值是 0，右下角的键值是 15。这样，使用起来会更
方便些。如果硬件扫描后已经翻译成 0-F 的键值了则更好。至于扫描至和键值的关系读者自
己定。
键盘系统功能调用入口地址：0XD300
1）0 号功能——等待读键
入口参数:

$a0 = 0 ; 功能号

出口参数： $v0=键值（0～0FH）。
功能：

等待用户按键，读到键后返回键值

2）1 号功能——非等待读键
入口参数:

$a0 = 1 ; 功能号

出口参数： $v0=键值（0～0FH，0FFH）。
功能： 检查键盘状态，如果有键，返回键值，否则返回 0FFH
下面是 BIOS 中键盘模块的源程序。
.text 0xFD30 ; 定义代码
SW

$S0, 0($SP)

ADDI

$SP, $SP, -4

SW

$S1, 0($SP)

ADDI

$SP, $SP, -4

; 将$S0 寄存器内容压栈
; 自行完成

……
JR

; 将$S0 寄存器内容压栈

$RA

; 子程序返回

下面来举例说明如何在用户程序中进行系统功能调用。比如要在 4 位数码管中显示
12345678 这个数，则程序是：
ADDI

$A0, $ZERO, 0

ADDI

$A2, $ZERO, 0x1234

ADDI

$A3, $ZERO, 0x5678

JAL

0XFC88

本章只是用 LED 数码管和键盘模块作为例子，
给出了 BIOS 系统功能调用程序是设计。
下面总结一下开发 BIOS 程序应该注意的几个问题，这些问题不仅仅适合 MiniSys-1A
系统的 BIOS 程序开发，也适合其他系统的 BIOS 程序开发。

•

开发人员要熟悉汇编编程。BIOS 程序一般采用汇编语言编写，以便能够在尽量小的
代码量下获得更高的运行效率。因此，编程人员一定要对指令系统非常熟悉，善于
用更少时序的指令序列完成相同的事情。由于 BIOS 是最底层软件，所以除了自己
的功能调用外，没有任何其他的功能调用可用，如果要调用 BIOS 自己的功能调用
的时候要注意不要形成循环调用（A 功能调用 B 功能，而 B 功能中又调用了 A 功
能）而造成死机。在 MiniSys 系统中，除非有特别办法处理，否则不允许功能调用
以及任何子程序的嵌套调用。
-129-

•

•

•

•

开发人员要熟悉硬件。由于 BIOS 程序直接操作硬件，它不仅和 CPU 有关，还与接
口部件等有关，所以开发人员需要对 CPU、接口部件、各种总线协议、各硬件部件
之间的时序关系以及外部设备等多个方面有详细的了解；
开发人员要规划好上层接口。因为 BIOS 还为操作系统以及应用程序提供软件接口，
开发前一定要将硬件的功能分门别类，规划成一个一个的功能模块，其中，最重要
的是设计好入口参数与出口参数以及应用软件和操作系统调用这些功能模块的方法。
通常入口/出口参数采用寄存器直接传递；
分配好模块，组织好存储区。由于 BIOS 要直接操作各类硬件，因此，如果是一个团
队合作完成，由于 BIOS 运行于核心层，而汇编语言可以操作系统中的任何端口和
任何地址下的存储空间，因此多人合作的时候，一定要规定好 BIOS 所要使用的存
储区以及在存储区中每个地址的使用方法。同时，应该向最终用户公布 BIOS 数据
区所在的存储器地址，以便操作系统或用户不会重用这些存储区。
进行严格的软件测试。BIOS 程序会以固件的形式固化到芯片中，因此如果已经发布
的 BIOS 程序出问题，更正是很麻烦的，有时候甚至是不可能的。因为修正后的程序
需要编程器才能写入到芯片中，所以 BIOS 程序在发布前一定要做严格测试。

