# 地址配置说明

## 核心问题：程序在 Minisys 上的放置位置

### 当前情况
我们的编译器**硬编码**了地址 `0x00000000`。这可能**不适合**你的 minisys。

### 需要的信息

#### 问题 1: 程序代码放在哪里？
```
你的 minisys FPGA 设计中：
- 指令存储器 (Instruction Memory) 的地址范围是什么？
- 例如：0x00000000 - 0x0000FFFF？
- 还是：0x80000000 - 0x8FFFFFFF？
- 还是其他？
```

#### 问题 2: 数据存储在哪里？
```
- 数据存储器 (Data Memory) 的地址范围？
- 栈 (Stack) 应该放在数据存储器的哪部分？
```

#### 问题 3: 从哪个地址开始执行？
```
- Minisys 复位后 PC 从哪里开始？
- 通常是 0x00000000 或 0x80000000
```

### 常见的 Minisys 配置

#### 配置A: 小型 FPGA (如 Basys3)
```
┌─────────────────────────────────┐
│ 内存地址空间                      │
├─────────────────────────────────┤
│ 0x00000000 - 0x00003FFF (16KB)  │ 程序代码
│ 0x00004000 - 0x00007FFF (16KB)  │ 数据
│ 0x00008000 - 0x00FFFFFF         │ 空
└─────────────────────────────────┘

编译器需要配置：
- 程序基址: 0x00000000
- 入口点: 0x00000000
- 栈起点: 0x00008000 (向下生长)
```

#### 配置B: 标准 RISC-V (如 Spike, QEMU)
```
┌─────────────────────────────────┐
│ 内存地址空间                      │
├─────────────────────────────────┤
│ 0x80000000 - 0x8FFFFFFF (256MB) │ DRAM
│ 0x80000000 - 0x80000FFF         │ 程序代码
│ 0x80001000 - 0x8FFFFFFF         │ 栈/堆/数据
└─────────────────────────────────┘

编译器需要配置：
- 程序基址: 0x80000000
- 入口点: 0x80000000
- 栈起点: 0x8FFFFFFF (向下生长)
```

#### 配置C: 带引导程序 (Bootloader)
```
┌─────────────────────────────────┐
│ 内存地址空间                      │
├─────────────────────────────────┤
│ 0x00000000 - 0x000000FF         │ Bootloader
│ 0x00000100 - 0x0000FFFF         │ 用户程序 ← 编译器目标
│ 0x00010000 - 0x00FFFFFF         │ 数据/栈
└─────────────────────────────────┘

编译器需要配置：
- 程序基址: 0x00000100
- 入口点: 0x00000100
- 栈起点: 0x01000000 (向下生长)
```

### 如何确定你的 Minisys 配置？

**方法1: 查看设计文档**
- 查找 Minisys 的内存控制器配置
- 查看 FPGA 顶层设计 (top.v / top.vhdl)

**方法2: 查看现有代码**
- 是否有其他程序已经下载过？
- 查看它们是如何配置的

**方法3: 查看引导加载程序**
- 如果有 bootloader，它会告诉你程序应该放在哪里

**方法4: 实验方式**
- 尝试不同的地址
- 看硬件是否能正确执行

### 配置文件位置

当确定了地址后，修改以下文件：

```bash
# 主要修改这个文件中的两处地址：
src/assembler/elf.rs

搜索：
1. entry: 0x00000000       ← 改这里为你的入口点
2. addr: 0x00000000        ← 改这里为你的程序基址
```

### 验证配置

修改后，验证地址是否正确：

```bash
# 1. 编译
cargo build --release

# 2. 生成 ELF
./target/release/riscv_compiler test.c test.elf

# 3. 查看地址
readelf -e test.elf | grep -E "entry|LOAD"

# 输出应该显示你设置的地址
```

## 总结

**立即需要的信息：**

提供以下任一即可：
1. Minisys 用户手册页码和内存布局图
2. 现有参考程序的反汇编输出 (`objdump -e`)
3. Minisys FPGA 设计的顶层文件内容
4. 程序应该放在的具体地址

**有了这个信息后，我可以：**
- ✅ 修改编译器配置
- ✅ 生成可直接下载的 ELF
- ✅ 验证地址正确性
