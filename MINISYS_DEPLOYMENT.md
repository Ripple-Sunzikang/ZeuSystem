# Minisys 硬件部署指南

## 下载代码到 Minisys 需要的信息

### 1. **内存地址映射** ⚠️ 关键
你的 minisys 开发板的内存布局是什么？

**需要确定的信息：**
```
┌─────────────────────────────┐
│ Minisys 内存映射             │
├─────────────────────────────┤
│ 程序代码放在哪里？ (地址?)    │  ← 需要这个信息
│ RAM 的起始地址？              │  ← 需要这个信息
│ RAM 的大小？                  │  ← 需要这个信息
│ 是否有只读存储器 (ROM)?       │  ← 需要这个信息
│ 栈指针初始值？                │  ← 需要这个信息
└─────────────────────────────┘
```

### 2. **当前代码的地址配置**

```bash
$ readelf -e output/test_basic.elf | grep -E "entry|LOAD"

入口点地址：               0x10000
...
LOAD           0x001000 0x00010000 0x00010000 0x00048 0x00048 R E 0x1000
```

**当前配置：**
- 程序入口点: `0x10000`
- 文本段加载地址: `0x10000`
- 物理地址: `0x10000`

### 3. **需要调整的地方**

根据你的 minisys 内存布局，可能需要修改：

#### a) 修改程序基址
编辑 `src/assembler/elf.rs`：

```rust
// 当前配置
let header = ElfHeader {
    entry: 0x10000,        // ← 改这里
    ...
};

sections.push(ElfSection {
    addr: 0x10000,         // ← 改这里
    ...
});
```

#### b) 修改栈指针
编辑 `src/codegen.rs`：

```rust
// 栈指针初始化
self.emit(&format!("addi sp, sp, -{}", stack_size));
// 栈增长方向和大小
```

### 4. **获取 Minisys 信息的方法**

**查阅资料：**
1. Minisys 用户手册/原理图
2. FPGA 项目的内存配置文件
3. 现有的参考代码

**典型问题：**
- "程序从哪个地址开始执行？"
- "RAM 在哪个地址？大小多少？"
- "是否需要 bootloader？"

### 5. **完整的部署流程**

```
步骤 1: 确认 Minisys 内存配置
        ↓
步骤 2: 根据配置调整编译器地址
        ↓
步骤 3: 编译代码生成 ELF
        ↓
步骤 4: 验证 ELF 地址正确
        ↓
步骤 5: 转换为下载格式 (hex/bin)
        ↓
步骤 6: 下载到 minisys
        ↓
步骤 7: 硬件执行验证
```

### 6. **可能需要的工具**

```bash
# 查看 ELF 信息
readelf -e program.elf

# 反汇编验证
riscv32-unknown-elf-objdump -d program.elf

# 提取二进制数据
riscv32-unknown-elf-objcopy -O binary program.elf program.bin

# 转换为 hex 格式（如需要）
xxd -p program.bin > program.hex
```

### 7. **常见问题**

**Q: 如何知道正确的地址？**
A: 查看 minisys 的系统设计文档或既有代码

**Q: 是否需要 bootloader？**
A: 取决于 minisys 的设计，通常需要

**Q: 栈应该放在哪里？**
A: 通常在 RAM 最高地址，向下生长

**Q: 是否需要初始化寄存器？**
A: 通常由硬件或 bootloader 完成

## 下一步

请提供以下信息，我可以帮你调整编译器配置：

1. **Minisys 的程序代码应放在哪个地址？**
   （例如：0x80000000, 0x10000, 等）

2. **RAM 的起始地址和大小？**
   （例如：0x80000000 - 0x8FFFFFFF）

3. **栈指针应初始化为什么值？**
   （例如：0x8FFFFFFF）

4. **是否有既有的参考程序或内存映射？**

有了这些信息，我可以：
- ✅ 调整编译器生成正确的地址
- ✅ 优化内存使用
- ✅ 生成可直接下载的二进制文件
